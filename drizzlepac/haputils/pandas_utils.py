""" Definition of Super and Subclasses for the mosaic output image_list

    Classes which define the total ("white light" image), filter, and exposure
    drizzle products.
"""
import array
from bokeh.layouts import row
from bokeh.plotting import figure, output_file, show
from bokeh.models import ColumnDataSource, Label
import csv
import glob
import json
import logging
import os
import sys
import pandas as pd
import pathlib
import shutil
import traceback

from stsci.tools import logutil
from astropy.io import fits
import numpy as np

MSG_DATEFMT = '%Y%j%H%M%S'
SPLUNK_MSG_FORMAT = '%(asctime)s %(levelname)s src=%(name)s- %(message)s'
log = logutil.create_logger(__name__, level=logutil.logging.NOTSET, stream=sys.stdout,
                            format=SPLUNK_MSG_FORMAT, datefmt=MSG_DATEFMT)
__version__ = 0.1
__version_date__ = '08-Jun-2020'


class PandasDFReader:
    """ A base class to read a Pandas dataframe generated by the HAP harvester.
    """
    def __init__(self, harvester_filename, log_level):
        # set logging level to user-specified level
        log.setLevel(log_level)
        self.log_level = log_level

        # Check for the existence of the input file.  There is no race condition
        # here, so this style of checking is fine.
        path = pathlib.Path(harvester_filename)
        if not path.is_file():
            log.error('Pandas dataframe file {} does not exist.'.format(harvester_filename))
            raise ValueError('Pandas dataframe file {} does not exist.')

        self.harvester_filename = harvester_filename

        # Lazy attribute creation
        self._dataframe = None

    def get_columns_CSV(self, column_names):
        """ Method to do the actual reading of dataframe and get the data in the
            specified columns.

            Parameters
            ----------
            column_names : list
            A list of the column names which specify the desired data.

            Returns
            -------
            column_data : Pandas dataframe
            A Pandas dataframe containing only the specified named columns where
            any rows containing NaNs have been eliminated.
        """
        # Only read the input dataframe once
        if self._dataframe is None:
            self._dataframe = pd.read_csv(self.harvester_filename)

        # Get the requested columns and eliminate all rows which have
        # NaNs in any of the requested columns.
        column_data = self._dataframe.loc[:, column_names].dropna()

        return column_data

    def get_columns_HDF5(self, column_names, do_drop=True):
        """ Method to do the actual reading of dataframe and get the data in the
            specified columns.

            Parameters
            ----------
            column_names : list
            A list of the column names which specify the desired data.

            do_drop : bool, optional (default is True indicating to drop the rows)
            Option to drop rows which contain NaNs in any of the requested columns.
            Option is set to True for backwards compatibility.

            Returns
            -------
            column_data : Pandas dataframe
            A Pandas dataframe containing only the specified named columns where
            any rows containing NaNs have been eliminated.
        """
        # Only read the input dataframe once
        if self._dataframe is None:
            hdf5 = pd.HDFStore(self.harvester_filename, mode="r")

            # Get the zeroth key from the file as there is really only one dataframe
            # stored in the file - just do not assume its key.
            key0 = hdf5.keys()[0]
            self._dataframe = hdf5.get(key0)

            hdf5.close()

        # Get the requested columns and eliminate, upon request, rows which have
        # NaNs in *any* of the requested columns. Because of the way some of the
        # data has been put into the dataframe (e.g., wcs), rows should not be eliminated.
        if do_drop:
            column_data = self._dataframe.loc[:, column_names].dropna()
        else:
            column_data = self._dataframe.loc[:, column_names]

        return column_data
