"""Code that evaluates the quality of the MVM products generated by the drizzlepac package.



"""

# Standard library imports
import argparse
import collections
from datetime import datetime
import glob
import itertools
import json
import math
import os
import pdb
import pickle
import sys
import time

# Related third party imports
from astropy.coordinates import SkyCoord
from astropy.io import ascii, fits
from astropy.stats import sigma_clipped_stats
from astropy.table import Table, Column
from bokeh.layouts import row, column
from bokeh.plotting import figure, output_file, save
from bokeh.models import ColumnDataSource, Label
from bokeh.models.tools import HoverTool
from itertools import combinations, chain
import numpy as np
from photutils.detection import DAOStarFinder
from scipy import ndimage
from scipy.spatial import KDTree


# Local application imports
from drizzlepac import util, wcs_functions
from drizzlepac.haputils import hla_flag_filter
from drizzlepac.haputils import catalog_utils
from drizzlepac.haputils import astrometric_utils as au
from drizzlepac.haputils import cell_utils
import drizzlepac.haputils.comparison_utils as cu
import drizzlepac.haputils.diagnostic_utils as du
from drizzlepac.devutils.comparison_tools import interdetector_sourcelist_crossmatch as idslxm
from drizzlepac.haputils import read_hla_catalog
from stsci.tools import logutil
from stsci.stimage import xyxymatch
from stwcs import wcsutil
from stwcs.wcsutil import HSTWCS

from drizzlepac.haputils import quality_analysis as qa
from drizzlepac.haputils.pandas_utils import PandasDFReader


__taskname__ = 'mvm_quality_analysis'

MSG_DATEFMT = '%Y%j%H%M%S'
SPLUNK_MSG_FORMAT = '%(asctime)s %(levelname)s src=%(name)s- %(message)s'
log = logutil.create_logger(__name__, level=logutil.logging.NOTSET, stream=sys.stdout,
                            format=SPLUNK_MSG_FORMAT, datefmt=MSG_DATEFMT)
# ------------------------------------------------------------------------------------------------------------

def run_quality_analysis(total_obj_list, run_overlap_crossmatch=True, log_level=logutil.logging.NOTSET):
    log.setLevel(log_level)
    if run_overlap_crossmatch:
        try:
            overlap_crossmatch_analysis(total_obj_list, log_level=log_level)
        except Exception:
            log.warning("The analysis of crossmatched sources in overlap regions encountered a problem.")
            log.exception("message")
            log.warning("Continuing to next test...")

# ------------------------------------------------------------------------------------------------------------


def overlap_crossmatch_analysis(total_obj_list, sourcelist_type="point", good_flags=[0,1], log_level=logutil.logging.NOTSET):
    log.setLevel(log_level)
    log.info('\n\n*****     Begin Quality Analysis Test: overlap_crossmatch_analysis.     *****\n')
    # 1: Determine if there is observations from multiple proposals/visits present in this dataset
    ippsss_list = []
    for total_obj in total_obj_list:
        for exp_obj in total_obj.edp_list:
            ippsss_list.append(exp_obj.exposure_name[:6])
    ippsss_list = list(set(ippsss_list))
    if len(ippsss_list) == 1:  # return if there is only data from a single visit
        log.warning("All observations in this dataset were from a single proposal/visit. This test requires observations from two or more proposal/visits.")
        log.warning("Continuing to next test...")
        return
    del ippsss_list

    # 2a: Identify if there are any overlapping regions in observations from different proposal/visits
    ctx_count_ra, ctx_map_ra, layer_dict, layer_ctr = determine_if_overlaps_exist(total_obj_list, log_level=log_level)
    num_overlaps = len(list(set(ctx_count_ra.flatten().tolist()))) - 2
    log.info("Number of datasets with unique instrument, detector, filter, proposal and visit combinations: {}".format(layer_ctr))
    log.info("Number of regions with two or more overlapping unique dataset footprints: {}".format(num_overlaps))
    if num_overlaps == 0:  # Return if no overlap regions are found
        log.warning("No overlapping footprints found.")
        log.warning("Continuing to next test...")
    array2fitsfile(ctx_map_ra, "ctx_footprint_total.fits", log_level=log_level)
    del(num_overlaps)

    # 2b: Identification of individual overlap regions
    overlap_dict = locate_overlap_regions(ctx_map_ra, layer_dict, log_level=log_level)

    # 3a: locate SVM-generated sourcelists and corresponding drizzled filter-level product imagery of overlapping observations for crossmatch
    overlap_dict = locate_svm_products(overlap_dict, sourcelist_type, log_level=log_level)


    sl_xy_column_name_dict = {"point": ["X-Center", "Y-Center"],
                              "segment": ["X-Centroid", "Y-Centroid"]}
    num_overlaps = len(overlap_dict.keys())
    for overlap_num, bit_value in zip(range(1, num_overlaps+1), sorted(overlap_dict)):
        # 3b: Raise warnings if SVM sourcelists and/or drizzled filter images couldn't be found
        not_found_flag = False
        for set_num in ["0", "1"]:
            if overlap_dict[bit_value]["svm_sourcelist_{}".format(set_num)] == None:
                log.warning("Unable to locate one or more SVM sourcelist(s) required for crossmatch!")
                not_found_flag = True
            if overlap_dict[bit_value]["svm_img_{}".format(set_num)] == None:
                log.warning("Unable to locate one or more SVM drizzled filter image(s) required for crossmatch!")
                not_found_flag = True
        if not_found_flag == True:
            if overlap_num < num_overlaps:
                log.warning("Continuing to next overlap region crossmatch analysis...")
            if overlap_num == num_overlaps:
                log.warning("Continuing to next test...")
            continue

        svm_img_data_list = []
        svm_sourcelist_list = []
        overlap_region_array = np.full_like(ctx_map_ra, np.nan)
        overlap_region_array[(overlap_dict[bit_value]["idx_ra"])] = 1
        array2fitsfile(overlap_region_array, "mask.fits", write_fitsfiles=True, log_level=log_level)

        for set_num in ["0", "1"]:
            setnum = int(set_num)
            # 4: read in SVM-generated sourcelists and drizzled filter product images
            svm_img_data_list.append(fits.open(overlap_dict[bit_value]["svm_img_{}".format(set_num)]))
            svm_sourcelist_list.append(Table.read(overlap_dict[bit_value]["svm_sourcelist_{}".format(set_num)], format='ascii.ecsv'))

            # 5: eliminate sources in overlap region with DQ values > 0
            just_sl_name = os.path.basename(overlap_dict[bit_value]["svm_sourcelist_{}".format(set_num)])
            log.info("{} sourcelist initial length: {}".format(just_sl_name, len(svm_sourcelist_list[0])))
            rows_to_remove = np.argwhere(np.isin(svm_sourcelist_list[setnum]["Flags"], good_flags, invert=True))
            svm_sourcelist_list[setnum].remove_rows(rows_to_remove)
            log.info("removed {} rows in sourcelist {} with flag values other than user-defined list of good values ({})".format(len(rows_to_remove), just_sl_name, good_flags))
            log.info("{} remain.\n".format(len(svm_sourcelist_list[setnum])))

            # 6: Compute new skycell-reference X, Y values from SVM sourcelist RA, Dec values
            ra_dec_values = np.stack((svm_sourcelist_list[setnum]['RA'], svm_sourcelist_list[setnum]['DEC']), axis=1)
            #xy_skycell = total_obj_list[overlap_dict[bit_value]["total_obj_list_idx_{}".format(set_num)]].skycell.wcs.all_world2pix(ra_dec_values, 1)  # generates SVM XY coords in skycell ref frame (also mask, ctx_map_ra)
            xy_skycell = total_obj_list[overlap_dict[bit_value]["total_obj_list_idx_{}".format(set_num)]].meta_wcs.all_world2pix(ra_dec_values, 1)  # generates SVM XY coords in total image ref frame (NOT IN SKYCELL REF FRAME)
            # add freshly computed X and Y columns to the existing sourcelist table
            new_x_col = Column(name="X-Skycell", data=xy_skycell[:, 0], dtype=np.float64)
            new_y_col = Column(name="Y-Skycell", data=xy_skycell[:, 1], dtype=np.float64)
            svm_sourcelist_list[setnum].add_column(new_x_col, index=2)
            svm_sourcelist_list[setnum].add_column(new_y_col, index=3)

            #write RA, Dec values to region file # TODO: REMOVE. this line is for development purposes only.
            table_to_regionfile(svm_sourcelist_list[setnum], ["RA", "DEC"],
                                just_sl_name.replace(".ecsv", "_radec.reg"))
            #write svm xy values to region file  # TODO: REMOVE. this line is for development purposes only.
            table_to_regionfile(svm_sourcelist_list[setnum], sl_xy_column_name_dict[sourcelist_type],
                                just_sl_name.replace(".ecsv", "_xy_svm.reg"))
            #write new XY values to region file # TODO: REMOVE. this line is for development purposes only.
            table_to_regionfile(svm_sourcelist_list[setnum], ["X-Skycell", "Y-Skycell"],
                                just_sl_name.replace(".ecsv", "_xy_skycell.reg"))

            # 7: eliminate sources not in overlap region
            #  TODO: Not really working correctly. Seek help.
            # mask = au.within_footprint(overlap_region_array,
            #                            total_obj_list[overlap_dict[bit_value]["total_obj_list_idx_{}".format(set_num)]].meta_wcs,
            #                            svm_sourcelist_list[setnum]["X-Skycell"].data,
            #                            svm_sourcelist_list[setnum]["Y-Skycell"].data)
            # log.info("removed {} sources outside overlap region bounds from {}.".format(len(np.where(mask == False)[0]), just_sl_name))
            # svm_sourcelist_list[setnum] = svm_sourcelist_list[setnum][mask]
            # log.info("{} remain.\n".format(len(svm_sourcelist_list[setnum])))
            # #write new XY values from overlap region to region file # TODO: REMOVE. this line is for development purposes only.
            # table_to_regionfile(svm_sourcelist_list[setnum], ["X-Skycell", "Y-Skycell"],
            #                     just_sl_name.replace(".ecsv", "_xy_trimmed_skycell.reg"))

        # 8: perform cross-match (see svm_quality_analysis.compare_interfilter_crossmatches)
        ref_index, comp_index, matched_lines_ref, matched_lines_comp = crossmatch_sources(overlap_dict[bit_value],
                                                                                          svm_sourcelist_list,
                                                                                          log_level=log_level)

        # 9: perform analysis of crossmatch results (see svm_quality_analysis.compare_interfilter_crossmatches)
        crossmatch_analysis(total_obj_list, overlap_dict[bit_value], svm_sourcelist_list, ref_index,
                            comp_index, matched_lines_ref, matched_lines_comp, log_level=log_level)
    print("\a\a\a")  # TODO: REMOVE. this line is for development purposes only.
    pdb.set_trace()  #  TODO: REMOVE. this line is for development purposes only.

# ------------------------------------------------------------------------------------------------------------


def array2fitsfile(ra2write, fitsfilename, write_fitsfiles=False, log_level=logutil.logging.NOTSET):
    """Temp subroutine. TODO: remove once development is complete.
    Writes a numpy 2-d array to a fits file.
    """
    log.setLevel(log_level)
    if write_fitsfiles:
        hdu = fits.PrimaryHDU(ra2write)
        hdu.writeto(fitsfilename, overwrite=True)
        log.debug("Wrote fits file {}.".format(fitsfilename))

# ------------------------------------------------------------------------------------------------------------


def table_to_regionfile(source_table, columns_to_write, outfilename):
    """Temp subroutine. TODO: remove once development is complete.
    writes out user-specified columns from a user-specified astropy table to a user-specified region file
    """
    out_table = source_table.copy()
    out_table.keep_columns(columns_to_write)
    out_table.write(outfilename, format="ascii", overwrite=True)
    log.debug("Wrote region file '{}' containing {} sources".format(outfilename, len(out_table)))

# ------------------------------------------------------------------------------------------------------------


def crossmatch_analysis(total_obj_list, overlap_info, svm_sourcelist_list, ref_index, comp_index,
                        matched_lines_ref, matched_lines_comp, log_level=logutil.logging.NOTSET):
    """Preform statistical analysis of crossmatch results

    Parameters
    ----------
    total_obj_list : list
        list of skycell objects that store all the information for a set of observations for a given filter

    overlap_info : dict
        dictionary containing all relevant information about a single region of overlappoing observations.

    svm_sourcelist_list : list
        two-element list of astropy.table objects containing the SVM catalogs to crossmatch

    log_level : int, optional
        The desired level of verboseness in the log statements displayed on the screen and written to the
        .log file.  Default value is 'NOTSET'.

    ref_index : int
        indicates which of the two svm sourcelists was used as the reference for crossmatch purposes. A value
        of '0' indicates the sourcelist that is the first element of svm_sourcelist_list was the reference,
        and a value of '1' indicates that the second svm_sourcelist_list sourcelist was used as the reference.

    comp_index : int
        indicates which of the two svm sourcelists was used as the comparison for crossmatch purposes. A value
        of '0' indicates the sourcelist that is the first element of svm_sourcelist_list was the comparison,
        and a value of '1' indicates that the second svm_sourcelist_list sourcelist was used as the comparison

    matched_lines_ref : list
        indices of the reference catalog that crossmatch to the corresponding element in matched_lines_comp.

    matched_lines_comp : list
        indices of the comparison catalog that crossmatch to the corresponding element in matched_lines_ref.

    Returns
    -------
    Nothing.
    """
    log.setLevel(log_level)

    # compile lists of matched X, Y, RA and DEC for calculation of differences
    ref_data = svm_sourcelist_list[ref_index]
    comp_data = svm_sourcelist_list[comp_index]
    matching_values_ref_x = ref_data['X-Skycell'][[matched_lines_ref]]
    matching_values_ref_y = ref_data['Y-Skycell'][[matched_lines_ref]]
    matching_values_ref_ra = ref_data['RA'][[matched_lines_ref]]
    matching_values_ref_dec = ref_data['DEC'][[matched_lines_ref]]
    matching_values_comp_x = comp_data['X-Skycell'][[matched_lines_comp]]
    matching_values_comp_y = comp_data['Y-Skycell'][[matched_lines_comp]]
    matching_values_comp_ra = comp_data['RA'][[matched_lines_comp]]
    matching_values_comp_dec = comp_data['DEC'][[matched_lines_comp]]

    # get coordinate system type total_obj info
    overlap_info["total_obj_list_idx_{}".format(str(ref_index))]
    ref_frame = total_obj_list[overlap_info["total_obj_list_idx_{}".format(str(ref_index))]].meta_wcs.wcs.radesys.lower()
    comp_frame = total_obj_list[overlap_info["total_obj_list_idx_{}".format(str(comp_index))]].meta_wcs.wcs.radesys.lower()

    # force RA and Dec values to be the correct type for SkyCoord() call
    if str(type(matching_values_ref_ra)) == "<class 'astropy.table.column.Column'>":
        matching_values_ref_ra = matching_values_ref_ra.tolist()
    if str(type(matching_values_ref_dec)) == "<class 'astropy.table.column.Column'>":
        matching_values_ref_dec = matching_values_ref_dec.tolist()
    if str(type(matching_values_comp_ra)) == "<class 'astropy.table.column.Column'>":
        matching_values_comp_ra = matching_values_comp_ra.tolist()
    if str(type(matching_values_comp_dec)) == "<class 'astropy.table.column.Column'>":
        matching_values_comp_dec = matching_values_comp_dec.tolist()

    # convert reference and comparison RA/Dec values into SkyCoord objects
    matching_values_ref_rd = SkyCoord(matching_values_ref_ra, matching_values_ref_dec, frame=ref_frame,
                                      unit="deg")
    matching_values_comp_rd = SkyCoord(matching_values_comp_ra, matching_values_comp_dec, frame=comp_frame,
                                       unit="deg")
    # convert to ICRS coord system
    if ref_frame != "icrs":
        matching_values_ref_rd = matching_values_ref_rd.icrs
    if comp_frame != "icrs":
        matching_values_comp_rd = matching_values_comp_rd.icrs

    # compute mean-subtracted differences
    diff_x = (matching_values_comp_x - matching_values_ref_x)
    diff_x -= sigma_clipped_stats(diff_x, sigma=3, maxiters=3)[0]
    diff_y = (matching_values_comp_y - matching_values_ref_y)
    diff_y -= sigma_clipped_stats(diff_y, sigma=3, maxiters=3)[0]
    diff_xy = np.sqrt(diff_x ** 2 + diff_y ** 2)
    diff_rd = matching_values_comp_rd.separation(matching_values_ref_rd).arcsec

    diff_list = [diff_x, diff_y, diff_xy, diff_rd]
    title_list = ["X-axis differences", "Y-axis differences", "Separation", "On-sky separation"]
    units_list = ["HAP pixels", "HAP pixels", "HAP pixels", "Arcseconds"]
    for diff_ra, title, units in zip(diff_list, title_list, units_list):
        log.info("Comparison - reference {} statistics ({})".format(title, units))
        idslxm.compute_stats(diff_ra, title, log_level=log_level)
# ------------------------------------------------------------------------------------------------------------


def crossmatch_sources(overlap_info, svm_sourcelist_list, log_level=logutil.logging.NOTSET):
    """identify sources found in both sourcelists using stsci.stimage.xyxymatch

    Parameters
    ----------
    overlap_info : dict
        dictionary containing all relevant information about a single region of overlappoing observations.

    svm_sourcelist_list : list
        two-element list of astropy.table objects containing the SVM catalogs to crossmatch

    log_level : int, optional
        The desired level of verboseness in the log statements displayed on the screen and written to the
        .log file.  Default value is 'NOTSET'.

    Returns
    -------
    ref_index : int
        indicates which of the two svm sourcelists was used as the reference for crossmatch purposes. A value
        of '0' indicates the sourcelist that is the first element of svm_sourcelist_list was the reference,
        and a value of '1' indicates that the second svm_sourcelist_list sourcelist was used as the reference.

    comp_index : int
        indicates which of the two svm sourcelists was used as the comparison for crossmatch purposes. A value
        of '0' indicates the sourcelist that is the first element of svm_sourcelist_list was the comparison,
        and a value of '1' indicates that the second svm_sourcelist_list sourcelist was used as the comparision.

    matched_lines_ref : list
        indices of the reference catalog that crossmatch to the corresponding element in matched_lines_comp.

    matched_lines_ref : list
        indices of the comparison catalog that crossmatch to the corresponding element in matched_lines_ref.
    """
    log.setLevel(log_level)
    # The sourcelist with more sources is automatically set as the "reference" catalog that the other
    # sourcelist (aka the "comparison" catalog) will be crossmatched to
    if len(svm_sourcelist_list[0]) >= len(svm_sourcelist_list[1]):
        ref_index = 0
        comp_index = 1
    else:
        ref_index = 1
        comp_index = 0

    log.info("Reference catalog: {}, {} sources".format(os.path.basename(overlap_info["svm_sourcelist_{}".format(str(ref_index))]), len(svm_sourcelist_list[ref_index])))
    log.info("Comparison catalog: {}, {} sources".format(os.path.basename(overlap_info["svm_sourcelist_{}".format(str(comp_index))]), len(svm_sourcelist_list[comp_index])))

    # prepare xyxymatch inputs
    ref_xy = np.stack((svm_sourcelist_list[ref_index]['X-Skycell'], svm_sourcelist_list[ref_index]['Y-Skycell']), axis=1)
    comp_xy = np.stack((svm_sourcelist_list[comp_index]['X-Skycell'], svm_sourcelist_list[comp_index]['Y-Skycell']), axis=1)
    
    # execute crossmatch
    matches = xyxymatch(comp_xy, ref_xy, tolerance=5.0, separation=1.0)

    # Report number and percentage of the total number of detected ref and comp sources that were matched
    log.info("Sourcelist Matching Results")
    log.info("Reference sourcelist:  {} of {} total sources matched ({} %)".format(len(matches), len(ref_xy), 100.0 * (float(len(matches)) / float(len(ref_xy)))))
    log.info("Comparison sourcelist: {} of {} total sources matched ({} %)".format(len(matches), len(comp_xy), 100.0 * (float(len(matches)) / float(len(comp_xy)))))

    # extract indices of the matching ref and comp lines and then use them to compile lists of matched X, Y,
    # RA and DEC for calculation of differences
    matched_lines_comp = []
    matched_lines_ref = []
    for item in matches:
        matched_lines_comp.append(item[2])
        matched_lines_ref.append(item[5])

    table_to_regionfile(svm_sourcelist_list[ref_index][matched_lines_ref], ["X-Skycell", "Y-Skycell"],
                        os.path.basename(overlap_info["svm_sourcelist_{}".format(str(ref_index))]).replace(".ecsv", "_match_ref_xy_skycell.reg")) #  TODO: REMOVE. this line is for development purposes only.
    table_to_regionfile(svm_sourcelist_list[comp_index][matched_lines_comp], ["X-Skycell", "Y-Skycell"],
                        os.path.basename(overlap_info["svm_sourcelist_{}".format(str(comp_index))]).replace(".ecsv", "_match_comp_xy_skycell.reg")) #  TODO: REMOVE. this line is for development purposes only.

    return ref_index, comp_index, matched_lines_ref, matched_lines_comp

#-------------------------------------------------------------------------------------------------------------



def determine_if_overlaps_exist(total_obj_list, log_level=logutil.logging.NOTSET):
    """determines if there are any regions where observartions overlap.

    Parameters
    ----------
    total_obj_list : list
        List of TotalProduct objects, one object per instrument/detector/filter combination

    log_level : int, optional
        The desired level of verboseness in the log statements displayed on the screen and written to the
        .log file.  Default value is 'NOTSET'.

    Returns
    -------
    ctx_count_ra : numpy.ndarray
        exposure population context array

    ctx_map_ra : numpy.ndarray
        exposure footprint context array

    layer_dict : dict
        Dictionary containing the drizzled filename and ippsss information for each exposure keyed by layer
        number (which ties this information to the ctx_map array)

    layer_ctr : int
        total number of individual "layers" or footprints present.
    """
    log.setLevel(log_level)
    layer_ctr = 0
    layer_dict = {}
    for tot_obj_list_idx, total_obj in zip(range(0, len(total_obj_list)), total_obj_list):
        if not total_obj.drizzle_filename.endswith("_coarse-all_drz.fits"):
            ippsss_list = []
            for exp_obj in total_obj.edp_list:
                ippsss_list.append(exp_obj.exposure_name[:6])
            ippsss_list = list(set(ippsss_list))
            for ippsss in ippsss_list:
                img_list = glob.glob("{}*_fl?.fits".format(ippsss))
                skycell = cell_utils.SkyCell.from_name(total_obj.skycell.sky_cell_id)
                footprint = cell_utils.SkyFootprint(meta_wcs=skycell.wcs)
                footprint.build(img_list)
                if layer_ctr == 0:
                    ctx_map_ra = np.zeros_like(footprint.total_mask, dtype=np.int64) # This should allow for a max of 35 unique footprints in the skycell
                    ctx_count_ra = np.zeros_like(footprint.total_mask)
                ctx_count_ra += np.where(footprint.total_mask == 0, footprint.total_mask, 1)  # Build array maps number of overlapping datasets for each skycell pixel
                ctx_map_ra += np.where(footprint.total_mask == 0, footprint.total_mask, 2**layer_ctr) # Build context arrray that stores footprint information broken down by instrument, detector, filter, proposal and visit
                layer_dict[2**layer_ctr] = {}
                layer_dict[2 ** layer_ctr]["mode"] = total_obj.drizzle_filename
                layer_dict[2 ** layer_ctr]["ippsss"] = ippsss
                layer_dict[2 ** layer_ctr]["total_obj_list_idx"] = tot_obj_list_idx
                array2fitsfile(ctx_map_ra, "ctx_footprint_{}.fits".format(str(layer_ctr)), log_level=log_level) # TODO: REMOVE. this line is for development purposes only.
                layer_ctr += 1

                # footprint_filename = total_obj.drizzle_filename.replace("all_dr", "all_{}_footprint_dr".format(ippsss))  # TODO: REMOVE. this line is for development purposes only.
                # foo = footprint.get_footprint_hdu(footprint_filename)  # TODO: REMOVE. this line is for development purposes only.
                # log.info("Wrote footprint file {}.".format(footprint_filename)) # TODO: REMOVE. this line is for development purposes only.

    return ctx_count_ra, ctx_map_ra, layer_dict, layer_ctr

#-------------------------------------------------------------------------------------------------------------


def locate_overlap_regions(ctx_map_ra, layer_dict, log_level=logutil.logging.NOTSET):
    """Locates all overlap region(s) present

    Parameters
    ----------
    ctx_map_ra : numpy.ndarray
        exposure footprint context array

    layer_dict : dict
        Dictionary containing the drizzled filename and ippsss information for each exposure keyed by layer
        number (which ties this information to the ctx_map array)

    log_level : int, optional
        The desired level of verboseness in the log statements displayed on the screen and written to the
        .log file.  Default value is 'NOTSET'.

    Returns
    -------
    overlap_dict : dict
        Dictionary keyed by the bit value of the overlap containing the following:
        1) values: a list of the bit values of the overlapping layers
        2) idx_ra: the x and y index values of all pixels in ctx_map_ra in this overlap region
        3) mode_0: the drizzle file name of the first component of the overlap
        4) ippsss_0: the ippsss of the dataset of the first component of the overlap
        5) mode_1: the drizzle file name of the second component of the overlap
        6) ippsss_01: the ippsss of the dataset of the second component of the overlap
    """
    log.setLevel(log_level)
    known_bits_list = sorted(layer_dict.keys())
    overlap_dict = {}
    test_bits_list = known_bits_list.copy()
    test_bits_list.reverse()
    test_bits_list = test_bits_list
    all_bit_values = list(set(ctx_map_ra.flatten().tolist()))
    indices = np.argwhere(np.isin(all_bit_values,
                                  known_bits_list))  # get list indices of list elements that are just single (not combination) bit values
    all_combo_bit_values = np.delete(all_bit_values, indices)  # remove single values from list.
    all_combo_bit_values = np.flip(all_combo_bit_values)
    for combo_value in all_combo_bit_values:
        idx_ra = np.where(ctx_map_ra == combo_value)
        bit_list = []
        for test_bit in test_bits_list:  # deconstruct each combination bit value into it's components
            if combo_value & test_bit > 0:
                bit_list.append(test_bit)
        for item in combinations(bit_list, 2):  # update overlap_dict with information about overlap(s) in this region.
            bitsum = item[0] + item[1]
            if bitsum in overlap_dict.keys():
                overlap_dict[bitsum]["idx_ra"][0] = np.concatenate(
                    (overlap_dict[bitsum]["idx_ra"][0], idx_ra[0]))
                overlap_dict[bitsum]["idx_ra"][1] = np.concatenate(
                    (overlap_dict[bitsum]["idx_ra"][1], idx_ra[1]))
            else:
                overlap_dict[bitsum] = {}
                overlap_dict[bitsum]["values"] = item
                overlap_dict[bitsum]["idx_ra"] = [idx_ra[0], idx_ra[1]]
                overlap_dict[bitsum]["mode_0"] = layer_dict[item[0]]["mode"]
                overlap_dict[bitsum]["ippsss_0"] = layer_dict[item[0]]["ippsss"]
                overlap_dict[bitsum]["total_obj_list_idx_0"] = layer_dict[item[0]]["total_obj_list_idx"]
                overlap_dict[bitsum]["mode_1"] = layer_dict[item[1]]["mode"]
                overlap_dict[bitsum]["ippsss_1"] = layer_dict[item[1]]["ippsss"]
                overlap_dict[bitsum]["total_obj_list_idx_1"] =layer_dict[item[1]]["total_obj_list_idx"]

    for foo in enumerate(sorted(overlap_dict.keys())):  # report basic information about each overlap
        ctr = foo[0]
        bit_value = foo[1]
        num_overlaps = len(overlap_dict.keys())
        num_pix = len(overlap_dict[bit_value]['idx_ra'][0])
        if num_pix == 1:
            plural_str = ""
        else:
            plural_str = "s"
        log.info("Overlap region #{}/{}, with overlap bit value {} contains {} pixel{}.".format(ctr + 1,
                                                                                                num_overlaps,
                                                                                                bit_value,
                                                                                                num_pix,
                                                                                                plural_str))

        overlap_test = np.zeros_like(ctx_map_ra)  # TODO: REMOVE. this line is for development purposes only.
        overlap_test[(overlap_dict[bit_value]["idx_ra"])] = 1  # TODO: REMOVE. this line is for development purposes only.
        array2fitsfile(overlap_test, "overlap_region_{}.fits".format(str(bit_value)), log_level=log_level)  # TODO: REMOVE. this line is for development purposes only.
    return overlap_dict

# ------------------------------------------------------------------------------------------------------------


def locate_svm_products(overlap_dict, sourcelist_type, log_level=logutil.logging.NOTSET):
    """ locate SVM-generated sourcelists and corresponding drizzled filter-level product imagery of
    overlapping observations for crossmatch

    Parameters
    ----------
    overlap_dict : dict
        Dictionary keyed by the bit value of the overlap containing the following:
        1) values: a list of the bit values of the overlapping layers
        2) idx_ra: the x and y index values of all pixels in ctx_map_ra in this overlap region
        3) mode_0: the drizzle file name of the first component of the overlap
        4) ippsss_0: the ippsss of the dataset of the first component of the overlap
        5) mode_1: the drizzle file name of the second component of the overlap
        6) ippsss_1: the ippsss of the dataset of the second component of the overlap

    sourcelist_type: str
        Type of sourcelist to search for. MUST be either "point" or "segment".

    log_level : int, optional
        The desired level of verboseness in the log statements displayed on the screen and written to the
        .log file.  Default value is 'NOTSET'.

    Returns
    -------
    overlap_dict : dict
        updated version of input arg 'overlap_dict' updated to include the full paths of the relevant
        sourcelists. New information is stored in keys "sourcelist_0" and sourcelist_1".
    """
    log.setLevel(log_level)
    inst_map = {"i": "wfc3", "j": "acs"}
    for bit_value in overlap_dict.keys():
        for set_num in ["0", "1"]:
            ippsss = overlap_dict[bit_value]["ippsss_{}".format(set_num)]
            mode = overlap_dict[bit_value]["mode_{}".format(set_num)]

            # build search strings for svm drz/drc filter image, corresponding sourcelist
            img_search_string = "{}{}".format(inst_map[ippsss[0]], mode.split(inst_map[ippsss[0]])[1])
            img_search_string = "hst_*_??_" + img_search_string.replace("all", ippsss)
            img_search_string = img_search_string.replace("drz", "dr?")
            sl_search_string = img_search_string.replace("dr?.fits", "{}-cat.ecsv".format(sourcelist_type))

            # build search paths.
            cwd = os.getcwd()
            search_path_list = []
            search_path_list.append(cwd+"/")
            search_path_list.append(cwd.replace(cwd.split("/")[-1], "svm_{}".format(ippsss))+"/")

            # execute searches
            for search_path in search_path_list:
                for search_item in [img_search_string, sl_search_string]:
                    full_search_string = search_path+search_item
                    results = glob.glob(full_search_string)
                    if results:
                        if results[0].endswith(".fits"):
                            overlap_dict[bit_value]["svm_img_{}".format(set_num)] = results[0]
                        else:
                            overlap_dict[bit_value]["svm_sourcelist_{}".format(set_num)] = results[0]

    return overlap_dict

# ------------------------------------------------------------------------------------------------------------


if __name__ == "__main__":
    pickle_in = open("total_obj_list_full.pickle", "rb")
    total_obj_list = pickle.load(pickle_in)

    run_quality_analysis(total_obj_list, log_level=logutil.logging.INFO)