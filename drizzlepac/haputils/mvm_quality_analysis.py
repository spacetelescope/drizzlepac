"""Code that evaluates the quality of the MVM products generated by the drizzlepac package.



"""

# Standard library imports
import argparse
import collections
from datetime import datetime
import glob
import itertools
import json
import math
import os
import pdb
import pickle
import sys
import time

# Related third party imports
from astropy.coordinates import SkyCoord
from astropy.io import ascii, fits
from astropy.stats import sigma_clipped_stats
from astropy.table import Table, Column
from bokeh.layouts import row, column
from bokeh.plotting import figure, output_file, save
from bokeh.models import ColumnDataSource, Label
from bokeh.models.tools import HoverTool
from itertools import combinations, chain
import numpy as np
from photutils.detection import DAOStarFinder
from scipy import ndimage
from scipy.spatial import KDTree

# Local application imports
from drizzlepac import util, wcs_functions
from drizzlepac.haputils import hla_flag_filter
from drizzlepac.haputils import catalog_utils
from drizzlepac.haputils import astrometric_utils as au
from drizzlepac.haputils import cell_utils
import drizzlepac.haputils.comparison_utils as cu
import drizzlepac.haputils.diagnostic_utils as du

from drizzlepac.haputils import read_hla_catalog
from stsci.tools import logutil
from stwcs import wcsutil
from stwcs.wcsutil import HSTWCS

from drizzlepac.haputils import quality_analysis as qa
from drizzlepac.haputils.pandas_utils import PandasDFReader


__taskname__ = 'mvm_quality_analysis'

MSG_DATEFMT = '%Y%j%H%M%S'
SPLUNK_MSG_FORMAT = '%(asctime)s %(levelname)s src=%(name)s- %(message)s'
log = logutil.create_logger(__name__, level=logutil.logging.NOTSET, stream=sys.stdout,
                            format=SPLUNK_MSG_FORMAT, datefmt=MSG_DATEFMT)
# ------------------------------------------------------------------------------------------------------------
def run_quality_analysis(total_obj_list, run_overlap_crossmatch=True, log_level=logutil.logging.NOTSET):
    log.setLevel(log_level)
    if run_overlap_crossmatch:
        try:
            overlap_crossmatch_analysis(total_obj_list, log_level=log_level)
        except Exception:
            log.warning("The analysis of crossmatched sources in overlap regions encountered a problem.")
            log.exception("message")
            log.warning("Continuing to next test...")

# ------------------------------------------------------------------------------------------------------------

def overlap_crossmatch_analysis(total_obj_list, log_level=logutil.logging.NOTSET):
    log.setLevel(log_level)
    log.info('\n\n*****     Begin Quality Analysis Test: overlap_crossmatch_analysis.     *****\n')
    # 1: Determine if there is observations from multiple proposals/visits present in this dataset
    ippsss_list = []
    for total_obj in total_obj_list:
        for exp_obj in total_obj.edp_list:
            ippsss_list.append(exp_obj.exposure_name[:6])
    ippsss_list = list(set(ippsss_list))
    if len(ippsss_list) == 1:  # return if there is only data from a single visit
        log.warning("All observations in this dataset were from a single proposal/visit. This test requires observations from two or more proposal/visits.")
        log.warning("Continuing to next test...")
        return
    del ippsss_list
    # 2a: Identify if there are any overlapping regions in observations from different proposal/visits
    ctx_count_ra, ctx_map_ra, layer_dict, layer_ctr = determine_if_overlaps_exist(total_obj_list, log_level=log_level)
    num_overlaps = len(list(set(ctx_count_ra.flatten().tolist()))) - 2
    log.info("Number of datasets with unique instrument, detector, filter, proposal and visit combinations: {}".format(layer_ctr))
    log.info("Number of regions with two or more overlapping unique dataset footprints: {}".format(num_overlaps))
    if num_overlaps == 0:  # Return if no overlap regions are found
        log.warning("No overlapping footprints found.")
        log.warning("Continuing to next test...")
    array2fitsfile(ctx_map_ra, "ctx_footprint_total.fits", log_level=log_level)

    # 2b: Identification of individual overlap regions
    overlap_dict = locate_overlap_regions(ctx_map_ra, layer_dict, log_level=log_level)


    print("\a\a")
    pdb.set_trace()
# ------------------------------------------------------------------------------------------------------------
def array2fitsfile(ra2write, fitsfilename, log_level=logutil.logging.NOTSET):
    """Temp subroutine. TODO: remove once development is complete."""
    log.setLevel(log_level)
    hdu = fits.PrimaryHDU(ra2write)
    hdu.writeto(fitsfilename)
    log.info("Wrote fits file {}.".format(fitsfilename))


# ------------------------------------------------------------------------------------------------------------
def determine_if_overlaps_exist(total_obj_list, log_level=logutil.logging.NOTSET):
    """determines if there are any regions where observartions overlap.

    Parameters
    ----------
    total_obj_list : list
        List of TotalProduct objects, one object per instrument/detector/filter combination

    log_level : int, optional
        The desired level of verboseness in the log statements displayed on the screen and written to the
        .log file.  Default value is 'NOTSET'.

    Returns
    -------
    ctx_count_ra : numpy.ndarray
        exposure population context array

    ctx_map_ra : numpy.ndarray
        exposure footprint context array

    layer_dict : dict
        Dictionary containing the drizzled filename and ippsss information for each exposure keyed by layer
        number (which ties this information to the ctx_map array)

    layer_ctr : int
        total number of individual "layers" or footprints present.
    """
    log.setLevel(log_level)
    layer_ctr = 0
    layer_dict = {}
    for total_obj in total_obj_list:
        if not total_obj.drizzle_filename.endswith("_coarse-all_drz.fits"):
            ippsss_list = []
            for exp_obj in total_obj.edp_list:
                ippsss_list.append(exp_obj.exposure_name[:6])
            ippsss_list = list(set(ippsss_list))
            for ippsss in ippsss_list:
                img_list = glob.glob("{}*_fl?.fits".format(ippsss))
                skycell = cell_utils.SkyCell.from_name(total_obj.skycell.sky_cell_id)
                footprint = cell_utils.SkyFootprint(meta_wcs=skycell.wcs)
                footprint.build(img_list)
                if layer_ctr == 0:
                    ctx_map_ra = np.zeros_like(footprint.total_mask, dtype=np.int64) # This should allow for a max of 35 unique footprints in the skycell
                    ctx_count_ra = np.zeros_like(footprint.total_mask)
                ctx_count_ra += np.where(footprint.total_mask == 0, footprint.total_mask, 1)  # Build array maps number of overlapping datasets for each skycell pixel
                ctx_map_ra += np.where(footprint.total_mask == 0, footprint.total_mask, 2**layer_ctr) # Build context arrray that stores footprint information broken down by instrument, detector, filter, proposal and visit
                layer_dict[2**layer_ctr] = {}
                layer_dict[2 ** layer_ctr]["mode"] = total_obj.drizzle_filename
                layer_dict[2 ** layer_ctr]["ippsss"] = ippsss

                array2fitsfile(ctx_map_ra, "ctx_footprint_{}.fits".format(str(layer_ctr)), log_level=log_level) # TODO: REMOVE. this line is for development purposes only.
                layer_ctr += 1

                footprint_filename = total_obj.drizzle_filename.replace("all_dr", "all_{}_footprint_dr".format(ippsss))  # TODO: REMOVE. this line is for development purposes only.
                foo = footprint.get_footprint_hdu(footprint_filename)  # TODO: REMOVE. this line is for development purposes only.
                log.info("Wrote footprint file {}.".format(footprint_filename)) # TODO: REMOVE. this line is for development purposes only.

    return ctx_count_ra, ctx_map_ra, layer_dict, layer_ctr

#-------------------------------------------------------------------------------------------------------------



def locate_overlap_regions(ctx_map_ra, layer_dict, log_level=logutil.logging.NOTSET):
    """Locates all overlap region(s) present

    Parameters
    ----------
    ctx_map_ra : numpy.ndarray
        exposure footprint context array

    layer_dict : dict
        Dictionary containing the drizzled filename and ippsss information for each exposure keyed by layer
        number (which ties this information to the ctx_map array)

    log_level : int, optional
        The desired level of verboseness in the log statements displayed on the screen and written to the
        .log file.  Default value is 'NOTSET'.

    Returns
    -------
    overlap_dict : dict
        Dictionary keyed by the bit value of the overlap containing the following:
        1) values: a list of the bit values of the overlapping layers
        2) idx_ra: the x and y index values of all pixels in ctx_map_ra in this overlap region
        3) mode_0: the drizzle file name of the first component of the overlap
        4) ippsss_0: the ippsss of the dataset of the first component of the overlap
        5) mode_1: the drizzle file name of the second component of the overlap
        6) ippsss_01: the ippsss of the dataset of the second component of the overlap
    """
    log.setLevel(log_level)
    known_bits_list = sorted(layer_dict.keys())
    overlap_dict = {}
    test_bits_list = known_bits_list.copy()
    test_bits_list.reverse()
    test_bits_list = test_bits_list
    all_bit_values = list(set(ctx_map_ra.flatten().tolist()))
    indices = np.argwhere(np.isin(all_bit_values,
                                  known_bits_list))  # get list indices of list elements that are just single (not combination) bit values
    all_combo_bit_values = np.delete(all_bit_values, indices)  # remove single values from list.
    all_combo_bit_values = np.flip(all_combo_bit_values)
    for combo_value in all_combo_bit_values:
        idx_ra = np.where(ctx_map_ra == combo_value)
        bit_list = []
        for test_bit in test_bits_list:  # deconstruct each combination bit value into it's components
            if combo_value & test_bit > 0:
                bit_list.append(test_bit)
        for item in combinations(bit_list, 2):  # update overlap_dict with information about overlap(s) in this region.
            bitsum = item[0] + item[1]
            if bitsum in overlap_dict.keys():
                overlap_dict[bitsum]["idx_ra"][0] = np.concatenate(
                    (overlap_dict[bitsum]["idx_ra"][0], idx_ra[0]))
                overlap_dict[bitsum]["idx_ra"][1] = np.concatenate(
                    (overlap_dict[bitsum]["idx_ra"][1], idx_ra[1]))
            else:
                overlap_dict[bitsum] = {}
                overlap_dict[bitsum]["values"] = item
                overlap_dict[bitsum]["idx_ra"] = [idx_ra[0], idx_ra[1]]
                overlap_dict[bitsum]["mode_0"] = layer_dict[item[0]]["mode"]
                overlap_dict[bitsum]["ippsss_0"] = layer_dict[item[0]]["ippsss"]
                overlap_dict[bitsum]["mode_1"] = layer_dict[item[1]]["mode"]
                overlap_dict[bitsum]["ippsss_1"] = layer_dict[item[1]]["ippsss"]

    for foo in enumerate(sorted(overlap_dict.keys())):  # report basic information about each overlap
        ctr = foo[0]
        bit_value = foo[1]
        num_overlaps = len(overlap_dict.keys())
        num_pix = len(overlap_dict[bit_value]['idx_ra'][0])
        if num_pix == 1:
            plural_str = ""
        else:
            plural_str = "s"
        log.info("Overlap region #{}/{}, with overlap bit value {} contains {} pixel{}.".format(ctr + 1,
                                                                                                num_overlaps,
                                                                                                bit_value,
                                                                                                num_pix,
                                                                                                plural_str))

        overlap_test = np.zeros_like(ctx_map_ra)  # TODO: REMOVE. this line is for development purposes only.
        overlap_test[(overlap_dict[bit_value]["idx_ra"])] = 1  # TODO: REMOVE. this line is for development purposes only.
        array2fitsfile(overlap_test, "overlap_region_{}.fits".format(str(bit_value)))  # TODO: REMOVE. this line is for development purposes only.
    return overlap_dict
