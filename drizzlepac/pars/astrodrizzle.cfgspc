_task_name_ = string_kw(default="astrodrizzle")
input = string_kw(default="*flt.fits", triggers='_rule1_', comment="Input files (name, suffix, or @list)")
output = string_kw(default='', comment="Rootname for output drizzled products")
_mdriztab_btn_ = action_kw(default='Update From MDRIZTAB', executes='_rule2_', comment='Immediately read and use the values from the MDRIZTAB')
runfile = string_kw(default="astrodrizzle.log", comment="File for logging the processing")
wcskey = string_kw(default="",comment="WCS version to use in processing")
proc_unit = option_kw("native", "electrons", default="native", comment="Units used during processing")
coeffs = boolean_kw(default=True, comment="Use header-based distortion coefficients?")
context = boolean_kw(default=True, comment="Create context image during final drizzle?")
group = string_kw(default="", comment="Single extension or group to be combined/cleaned")
build = boolean_kw(default=False, comment="Create multi-extension output file for final drizzle?")
crbit = integer_kw(default=4096, comment="Bit value for CR ident. in DQ array")
stepsize = integer_kw(default=10, comment="Step size for drizzle coordinate computation")
resetbits = string_kw(default="4096", comment="Bit values to reset in all input DQ arrays")
num_cores = integer_or_none_kw(default=None, inactive_if='_rule_mem_', comment="Max CPU cores to use (n<2 disables, None = auto-decide)")
in_memory = boolean_kw(default=False, triggers='_rule_mem_', comment="Process everything in memory to minimize disk I/O?")
rules_file = string_kw(default="", comment="Rules file to be used for blending headers")

[STATE OF INPUT FILES]
restore = boolean_kw(default=False, comment="Copy input files FROM archive directory for processing?")
preserve = boolean_kw(default=True, comment="Copy input files to archive directory, if not already archived?")
overwrite = boolean_kw(default=False, comment="Copy input files into archive, overwriting if required?")
clean = boolean_kw(default=False, comment="Delete temporary files after completion?")


[STEP 1: STATIC MASK ]
static = boolean_kw(default=True, triggers='_section_switch_',triggers='_rule2a_', comment="Create static bad-pixel mask from the data?")
static_sig = float_kw(default=4.0, comment= "Sigma*rms below mode to clip for static mask")

[STEP 2: SKY SUBTRACTION ]
skysub = boolean_kw(default=True, triggers='_section_switch_', triggers='_rule2b_', comment= "Perform sky subtraction?")
skymethod = option_kw("globalmin+match","localmin", "globalmin", "match", default="localmin", comment="Sky computation method")
skystat = option_kw("median","mode","mean", default="median", comment= "Sky correction statistics parameter")
skywidth = float_or_none_kw(default=0.1, comment= "Bin width of histogram for sampling sky statistics (in sigma)")
skylower = float_or_none_kw(default=None, comment= "Lower limit of usable data for sky (always in electrons)")
skyupper = float_or_none_kw(default=None, comment= "Upper limit of usable data for sky (always in electrons)")
skyclip = integer_kw(default=5, comment= "Number of clipping iterations")
skylsigma = float_kw(default=4., comment="Lower side clipping factor (in sigma)")
skyusigma = float_kw(default=4., comment="Upper side clipping factor (in sigma)")
skymask_cat = string_kw(default="", comment="Catalog file listing image masks")
use_static = boolean_kw(default=True, active_if='_rule2a_', comment= "Use static mask for skymatch computations?")
sky_bits = string_kw(default="0", comment="Integer mask bit values considered good pixels in DQ array")
skyfile = string_kw(default="", comment="Name of file with user-computed sky values to be subtracted")
skyuser = string_kw(default="", inactive_if='_rule2b_', comment="KEYWORD indicating a sky subtraction value if done by user")

[STEP 3: DRIZZLE SEPARATE IMAGES]
driz_separate = boolean_kw(default=True, triggers='_section_switch_', triggers='_rule3a_', is_set_by='_rule1_', comment= "Drizzle onto separate output images?")
driz_sep_kernel = option_kw("turbo","square","point", "gaussian", "tophat", "lanczos3", default="turbo", comment="Shape of kernel function")
driz_sep_wt_scl = string_kw(default="exptime", comment= "Weighting factor for input data image")
driz_sep_pixfrac = float_kw(default=1., comment="Linear size of drop in input pixels")
driz_sep_fillval = float_or_none_kw(default=None, comment="Value to be assigned to undefined output points")
driz_sep_bits = string_kw(default="0", comment="Integer mask bit values considered good")
driz_sep_compress = boolean_kw(default=False, comment= "Use compression when writing out product?")

[STEP 3a: CUSTOM WCS FOR SEPARATE OUTPUTS]
driz_sep_wcs = boolean_kw(default=False, triggers='_section_switch_', is_disabled_by='_rule3a_', comment= "Define custom WCS for separate output images?")
driz_sep_refimage = string_kw(default="", triggers='_rule4a_', comment="Reference image from which to obtain a WCS")
driz_sep_rot = float_or_none_kw(default=None, comment= "Position Angle of drizzled image's Y-axis w.r.t. North (degrees)")
driz_sep_scale = float_or_none_kw(default=None, comment="Absolute size of output pixels in arcsec/pixel")
driz_sep_outnx = integer_or_none_kw(default=None, comment="Size of separate output frame's X-axis (pixels)" )
driz_sep_outny = integer_or_none_kw(default=None, comment="Size of separate output frame's Y-axis (pixels)")
driz_sep_ra = float_or_none_kw(default=None, comment="right ascension output frame center in decimal degrees")
driz_sep_dec = float_or_none_kw(default=None, comment="declination output frame center in decimal degrees")
driz_sep_crpix1 = float_or_none_kw(default=None, comment="Reference pixel X position on output (CRPIX1)")
driz_sep_crpix2 = float_or_none_kw(default=None, comment="Reference pixel Y position on output (CRPIX2)")

[STEP 4: CREATE MEDIAN IMAGE]
median = boolean_kw(default=True, triggers='_section_switch_', is_set_by='_rule1_', comment= "Create a median image?")
median_newmasks= boolean_kw(default=True, comment= "Create new masks when doing the median?")
combine_maskpt = float_kw(default=0.3, comment= "Percentage of weight image value below which it is flagged as a bad pixel.")
combine_type = option_kw("minmed","iminmed","median","mean","imedian","imean","sum",default="minmed", comment= "Type of combine operation")
combine_nsigma = string_kw(default="4 3", comment= "Significance for accepting minimum instead of median")
combine_nlow = integer_kw(default=0, comment= "minmax: Number of low pixels to reject")
combine_nhigh = integer_kw(default=0, comment= "minmax: Number of high pixels to reject")
combine_lthresh = float_or_none_kw(default=None, comment="Lower threshold for clipping input pixel values")
combine_hthresh = float_or_none_kw(default=None, comment= "Upper threshold for clipping input pixel values")
combine_grow = integer_kw(default=1, comment=" Radius (pixels) for neighbor rejection")
combine_bufsize = float_or_none_kw(default=None, comment= "Size of buffer(in Mb) for each input image")

[STEP 5: BLOT BACK THE MEDIAN IMAGE]
blot = boolean_kw(default=True, triggers='_section_switch_', is_set_by='_rule1_', comment= "Blot the median back to the input frame?")
blot_interp = option_kw("poly5","nearest","linear", "poly3", "sinc",default="poly5", comment="Interpolant (nearest,linear,poly3,poly5,sinc)")
blot_sinscl = float_kw(default=1.0, comment="Scale for sinc interpolation kernel")
blot_addsky = boolean_kw(default=True, triggers='_rule5_', comment= "Add sky using MDRIZSKY value from header?")
blot_skyval = float_kw(default=0.0, active_if='_rule5_', comment="Custom sky value to be added to blot image")

[STEP 6: REMOVE COSMIC RAYS WITH DERIV, DRIZ_CR]
driz_cr = boolean_kw(default=True, triggers='_section_switch_', is_set_by='_rule1_', comment="Perform CR rejection with deriv and driz_cr?")
driz_cr_corr = boolean_kw(default=False, comment= "Create CR cleaned _crclean file and a _crmask file?")
driz_cr_snr = string_kw(default="3.5 3.0", comment= "Driz_cr.SNR parameter")
driz_cr_grow = integer_kw(default=1, comment="Driz_cr_grow parameter")
driz_cr_ctegrow = integer_kw(default=0, comment="Driz_cr_ctegrow parameter")
driz_cr_scale = string_kw(default="1.2 0.7", comment="Driz_cr.scale parameter")

[STEP 7: DRIZZLE FINAL COMBINED IMAGE]
driz_combine = boolean_kw(default=True, triggers='_section_switch_', triggers='_rule7a_', comment= "Perform final drizzle image combination?")
final_wht_type = option_kw("EXP","ERR","IVM",default="EXP", comment="Type of weighting for final drizzle")
final_kernel = option_kw("square", "point",  "gaussian", "turbo", "tophat", "lanczos3", default="square", comment="Shape of kernel function")
final_wt_scl = string_kw(default="exptime", comment="Weighting factor for input data image")
final_pixfrac = float_kw(default=1., comment="Linear size of drop in input pixels")
final_fillval = float_or_none_kw(default=None, comment= "Value to be assigned to undefined output points")
final_maskval = float_or_none_kw(default=None, comment= "Value to be assigned to regions outside SCI image")
final_bits = string_kw(default="0", comment="Integer mask bit values considered good")
final_units = option_kw("counts", "cps", default="cps", comment="Units for final drizzle image (counts or cps)")

[STEP 7a: CUSTOM WCS FOR FINAL OUTPUT]
final_wcs = boolean_kw(default=False, triggers='_section_switch_', is_disabled_by='_rule7a_', comment= "Define custom WCS for final output image?")
final_refimage = string_kw(default="", triggers='_rule4b_', comment="Reference image from which to obtain a WCS")
final_rot = float_or_none_kw(default=None, comment= "Position Angle of drizzled image's Y-axis w.r.t. North (degrees)")
final_scale = float_or_none_kw(default=None, comment="Absolute size of output pixels in arcsec/pixel")
final_outnx = integer_or_none_kw(default=None, comment= "Size of FINAL output frame X-axis (pixels)")
final_outny = integer_or_none_kw(default=None, comment="Size of FINAL output frame Y-axis (pixels)")
final_ra = float_or_none_kw(default=None, comment="Right ascension output frame center in decimal degrees")
final_dec = float_or_none_kw(default=None, comment="Declination output frame center in decimal degrees")
final_crpix1 = float_or_none_kw(default=None, comment="Reference pixel X position on output (CRPIX1)")
final_crpix2 = float_or_none_kw(default=None, comment="Reference pixel Y position on output (CRPIX2)")

[INSTRUMENT PARAMETERS]
gain = string_kw(default="")
gnkeyword = string_kw(default="")
rdnoise = string_kw(default="")
rnkeyword = string_kw(default="")
exptime  = string_kw(default="")
expkeyword = string_kw(default="")
#mode,s,h,"al",,,

[ _RULES_ ]
_rule1_ = string_kw(default='', when='entry', code='from stsci.tools import check_files; from drizzlepac import util; ans={ True:"yes",False:"no"};numfiles = check_files.countInput(VAL); OUT =  util.displayEmptyInputWarningBox(VAL,PARENT) if numfiles == 0 else ans[(numfiles > 1)]; TEAL.freshenFocus()')
_rule1a_ = string_kw(default='', when='defaults,entry', code='from drizzlepac import util; ans={ True:"yes",False:"no"}; OUT = ans[util.displayMakewcsWarningBox(VAL, PARENT)]')
_rule2_ = string_kw(default='', code='from drizzlepac import processInput; odict=TEAL.getDict(); newdict = processInput.getMdriztabPars(odict["input"]); TEAL.loadDict(newdict); TEAL.showStatus("Loaded MDRIZTAB values",keep=1) ')
_rule2a_ = string_kw(default=True, code='tyfn={"yes":True, "no":False}; OUT = tyfn[VAL]')
_rule2b_ = string_kw(default=True, code='tyfn={"yes":True, "no":False}; OUT = tyfn[VAL]')
#_rule2a_ = string_kw(default=True, code='from drizzlepac import util; OUT = util.useStaticRule(NAME, VAL)')
_rule3a_ = string_kw(default='', code='OUT = VAL')
_rule4a_ = string_kw(default='',code='from drizzlepac import util; validref = util.verifyRefimage(VAL); ans={True:"yes",False:"no"}; OUT= util.displayBadRefimageWarningBox(True,PARENT) if validref == False else ans[validref]')
_rule4b_ = string_kw(default='',code='from drizzlepac import util; validref = util.verifyRefimage(VAL); ans={True:"yes",False:"no"}; OUT=util.displayBadRefimageWarningBox(True,PARENT) if validref == False else ans[validref]')
_rule5_ = string_kw(default=True, when='defaults,entry', code='opposite={"yes":False, "no":True}; OUT = opposite[VAL]')
_rule7a_ = string_kw(default='', code='OUT = VAL')
_rule_mem_ = string_kw(default=True, code='tyfn={"yes":True, "no":False}; OUT = tyfn[VAL]')
