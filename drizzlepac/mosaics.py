"""This module provides the primary interface for creating all mosaics.

The design represented here elminates any difference between single-visit and
multi-visit mosaics by always working with only one visit or obset at a time
to create a mosaic (ala pipeline) and, if requested, a cell (ala Pan-STARRS).
Management of all the cells then takes place elsewhere by providing the user
what layers of that cell they are interested in, where each layer would be from
every obset that contributed to that cell.

"""
from astropy.io import fits
from stwcs.wcsutil import HSTWCS
from stwcs.distortion import utils
from stsci.tools import fileutil as fu

def select_product(exposures, info, mosaic_wcs=None):
    """Factory function to return appropriate class object for specified info.
    When fully implemented, this will return one of the following:

        * WFC3UVISProduct, WFC3IRProduct
        * ACSWFCProduct, ACSHRCProduct, ACSSBCProduct
        * ACSWFCMosaic, ACSSBCMosaic, ACSHRCMosaic
        * WFC3UVISMosaic, WFC3IRMosaic

    """
    return Product(exposures, info)

class Product(object):
    """This super-class defines the API for creating any product for an obset."""
    plate_scale = 0.04  # default plate scale for product
    pixfrac = 1.0
    kernel = 'square'
    bits = 256

    def __init__(self, exposures, obs_info):
        """
        Parameters
        ----------
        exposures : list
            List of filenames for all exposures contributing to this product

        obs_info : dict
            Dictionary of information specifying each member product, and it's
            relationship to the product or member as generated by
            ~generate_final_product_filenames.py of the format:

            obs_info_dict["single exposure product 00"] = {'info': '11150 A1S WFC3 IR F110W IA1S70JTQ',
                                                            'files':['ia1s70jtq_flt.fits']}
            obs_info_dict["single exposure product 01"] = {'info': '11150 A1S WFC3 IR F160W IA1S70JWQ',
                                                            'files':['ia1s70jwq_flt.fits']}
            obs_info_dict["filter product 00"] = {"info": '11150 A1S WFC3 IR F110W',
                                                  "files":['ia1s70jtq_flt.fits']}
            obs_info_dict["filter product 01"] = {"info": '11150 A1S WFC3 IR F160W',
                                                  "files":['ia1s70jwq_flt.fits']}
            obs_info_dict["total detection product 00"] = {'info': '11150 A1S WFC3 IR',
                                                           'files':['ia1s70jtq_flt.fits',
                                                                    'ia1s70iwq_flt.fits']}
        """
        self.info = obs_info
        self.mosaic_wcs = None

        self._define_exposures()
        self._define_members()

        # define product name
        self.proposal_id = obs_info[0]
        self.visit_id = obs_info[1]
        self.instrument = obs_info[2]
        self.detector = obs_info[3]
        self.obs_date = None  # need to define this somehow...

        self.basename = "hst_{}_{}_{}_{}.fits".format(proposal_id, visit_id, instrument, detector)
        self.cellname_fmt = "cell_{}_hst_{}_{}_{}.fits"

    def _define_exposures(self):
        """Define exposures attributes of Product."""
        self.exposures = {}
        for member in self.info:
            if 'exposure' not in member:
                continue
            # Only working with single exposure entries...
            obs_info = member['info']
            basename = 'hst_' + '_'.join(map(str, obs_info[:5])) + "_" + obs_info[5][:8] + "_" + obs_info[6] + '.fits'
            with fobj as fits.open(member):
                num_sci = fu.countExtn(fobj)
                wcslist = [HSTWCS(fobj, ext=extn for extn in range(1, num_sci+1)]

            self.exposures[member['files'][0]] = {'basename': basename,
                                                   'wcslist':wcslist}

    def _define_members(self):
        """Define members attribute of Product.

        TBD:May be a property
        """
        self.members = []
        for member, member_dict in self.info.items():
            if 'exposure' in member:
                continue  # exposures already processed
            # working with member products now...
            self.members.append(select_product(member_dict['files'], member_dict['info'], self.mosaic_wcs))

    def generate_mosaic(self):
        """Create mosaic product using astrodrizzle by combining all exposures.
        If mosaic_wcs was not already defined, it will be defined here.
        """
        # Run astrodrizzle on self.exposures with 'final_rot=0'
        # and 'final_scale=self.plate_scale', where self.plate_scale
        # would be defined specifically for this product, then define
        # self.mosaic_wcs as WCS of total product.
        #
        # Also, rename the single_sci products as exposure
        # products using self.exposures[filename]['name']
        #
        # Finish by creating the source catalog from the product
        #
        pass

    def populate_cell(self):
        """Only to be defined for sub-classes."""
        pass

    def process_members(self, mosaic=True):
        """Generate additional products defined for this obset"""
        for member in self.members:
            if mosaic:
                member.generate_mosaic()
            if cell:
                member.populate_cell()

class Mosaic(Product):

    def __init__(self, exposures, obs_info, mosaic_wcs):
        super().__init__(exposures, obs_info)
        self.mosaic_wcs = mosaic_wcs

        # Now define product level product name
        self.proposal_id = obs_info[0]
        self.visit_id = obs_info[1]
        self.instrument = obs_info[2]
        self.detector = obs_info[3]
        self.filter = obs_info[4]
        self.basename = "hst_{}_{}_{}_{}_{}.fits".format(self.proposal_id,
                                                         self.visit_id,
                                                         self.instrument,
                                                         self.detector,
                                                         self.filter)
        self.cellname_fmt = "cell_{}_hst_{}_{}_{}_{}.fits"

    def generate_mosaic(self):
        """Create mosaic product based on input mosaic_wcs"""

        # Run astrodrizzle on exposures with output WCS pre-defined by
        # mosaic_wcs, with 'in_memory=True' and 'clean=True'
        # create source catalog from product
        pass

    def populate_cell(self):
        """Identify sky cell this product overlaps and create new sky cell
        based on exposures.
        """
        # call function to identify sky cell mosaic_wcs overlaps.

        # For each cell this mosaic overlaps,
        # define cell name using cell ID
        #cellname = self.cellname_fmt.format(cell_id,
        #                                     self.instrument,
        #                                     self.detector,
        #                                     self.filter,
        #                                     self.obs_date)
        #
        # run astrodrizzle on self.exposures with output WCS defined by cell WCS
        # with 'output=cellname'
        pass

#
# Classes which define the total product
#
class ACSWFCProduct(Product):
    plate_scale=0.05

    def __init__(self, exposures, info):
        super().__init__(exposures, info)

class ACSSBCProduct(Product):
    plate_scale = 0.03

    def __init__(self, exposures, info):
        super().__init__(exposures, info)

class ACSHRCProduct(Product):
    plate_scale = 0.025

    def __init__(self, exposures, info):
        super().__init__(exposures, info)

class WFC3UVISProduct(Product):
    plate_scale=0.04

    def __init__(self, exposures, info):
        super().__init__(exposures, info)

class WFC3IRProduct(Product):
    plate_scale=0.09
    bits = 768

    def __init__(self, exposures, info):
        super().__init__(exposures, info)

#
# Sub-classes which define the filter products, both mosaics and cells
#
class ACSWFCMosaic(Mosaic):
    plate_scale=0.05

    def __init__(self, exposures, info, mosaic_wcs):
        super().__init__(exposures, info, mosaic_wcs=mosaic_wcs)

class ACSSBCMosaic(Mosaic):
    plate_scale=0.03

    def __init__(self, exposures, info, mosaic_wcs):
        super().__init__(exposures, info, mosaic_wcs=mosaic_wcs)

class ACSHRCMosaic(Mosaic):
    plate_scale=0.025

    def __init__(self, exposures, info, mosaic_wcs):
        super().__init__(exposures, info, mosaic_wcs=mosaic_wcs)

class WFC3UVISMosaic(Mosaic):
    plate_scale=0.04

    def __init__(self, exposures, info, mosaic_wcs):
        super().__init__(exposures, info, mosaic_wcs=mosaic_wcs)

class WFC3IRMosaic(Mosaic):
    plate_scale=0.09
    bits = 768

    def __init__(self, exposures, info, mosaic_wcs):
        super().__init__(exposures, info, mosaic_wcs=mosaic_wcs)

#
#
# Primary user interface for processing an obset
#
#
def process_obset(obs_info, mosaic=True, cell=True):

    # find total product, regardless of exact label
    # this assumes only 1 total product per obs_info dictionary
    for k in obs_info:
        if 'total' in k:
            total_product = select_product(obs_info[k])
            break
    # Generate total mosaic and single exposure Products
    total_product.generate_mosaic()
    total_wcs = total_product.mosaic_wcs
    # Process all members
    total_product.process_members(mosaic=mosaic, cell=cell)
